<!-- digital edition nav -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/splidejs/4.1.4/css/splide-core.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/splidejs/4.1.4/css/themes/splide-default.min.css">
<link href="https://cdn.jsdelivr.net/npm/glider-js@1.7.8/glider.min.css" rel="stylesheet">



<link
    rel="stylesheet"
    type="text/css"
    href="https://harpoonproductions.github.io/shorthand_utilities/dummy-magazine/style.css"
      />


<!-- Manifest & icons (root) -->
<link rel="manifest" href="/manifest.json">
<link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon-180.png">
<link rel="icon" href="/icons/icon-192.png">
<meta name="theme-color" content="#0a0a0a">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- Helper: detect installed PWA vs normal tab -->
<script>
  window.__isStandalone =
    window.matchMedia('(display-mode: standalone)').matches ||
    window.navigator.standalone === true;
</script>

<!-- OneSignal (permission gated to PWA only) -->
<!-- OneSignal (permission gated to PWA only, with domain sanity-check) -->
<!-- OneSignal (v16, PWA-gated, without getPermissionStatus) -->
<script src="https://cdn.onesignal.com/sdks/web/v16/OneSignalSDK.page.js" defer></script>
<script>
  window.OneSignalDeferred = window.OneSignalDeferred || [];
  OneSignalDeferred.push(async function (OneSignal) {
    const expectedOrigin = "https://dummy-magazine.com";
    const currentOrigin = window.location.origin;

    if (currentOrigin !== expectedOrigin) {
      console.warn(
        "[OneSignal] Skipping init. Expected origin:",
        expectedOrigin,
        "but running on:",
        currentOrigin
      );
      return;
    }

    const dmStandalone = window.matchMedia("(display-mode: standalone)").matches;
    const iosStandalone = window.navigator.standalone === true;
    const helperStandalone = window.__isStandalone === true;
    const debugOverride = window.location.search.includes("source=pwa-debug");

    console.log("[OneSignal] debug display-mode standalone =", dmStandalone);
    console.log("[OneSignal] debug navigator.standalone    =", iosStandalone);
    console.log("[OneSignal] debug window.__isStandalone   =", helperStandalone);
    console.log("[OneSignal] debug ?source=pwa-debug       =", debugOverride);

    const isPwaContext =
      helperStandalone || dmStandalone || iosStandalone || debugOverride;

    console.log("[OneSignal] isPwaContext =", isPwaContext);
    console.log("[OneSignal] init starting on", currentOrigin);

    // Optional, but handy while we’re still tweaking things
    OneSignal.Debug.setLogLevel("debug");

    let initOk = false;

    // 1) Init OneSignal (don’t throw away the whole flow if it fails)
    try {
      const appId = "81c48753-9d1c-4306-8bdd-968ecbb5a27d";
      await OneSignal.init({ appId });
      initOk = true;
      console.log("[OneSignal] init completed successfully");
    } catch (e) {
      console.error("[OneSignal] init error", e);
    }

    // 2) Only *ask* for permission inside the PWA (or debug override)
    if (!isPwaContext) {
      console.info("[OneSignal] Not PWA context, skipping permission request");
      return;
    }

    // 3) Read current permission
    const browserPerm =
      typeof Notification !== "undefined" ? Notification.permission : "unsupported";
    console.log("[OneSignal] Notification.permission (before) =", browserPerm);

    // For v16, OneSignal.Notifications.permission is a boolean-ish,
    // but we mostly care if the browser says "default" or "granted/denied".
    const alreadyDecided = browserPerm === "granted" || browserPerm === "denied";

    // 4) Use OneSignal slidedown if possible and permission not yet decided
    try {
      if (!alreadyDecided && initOk && OneSignal.Slidedown) {
        console.log("[OneSignal] Showing OneSignal slidedown prompt…");
        await OneSignal.Slidedown.promptPush({
          // While testing, force will show it even if OneSignal thinks it has
          // shown a prompt recently. Remove or set false for production.
          force: true,
        });
      } else if (!alreadyDecided && initOk && OneSignal.Notifications?.requestPermission) {
        console.log("[OneSignal] Calling OneSignal.Notifications.requestPermission()…");
        await OneSignal.Notifications.requestPermission();
      } else if (!alreadyDecided && typeof Notification !== "undefined" && Notification.requestPermission) {
        console.log("[OneSignal] Falling back to native Notification.requestPermission()…");
        await Notification.requestPermission();
      } else {
        console.log(
          "[OneSignal] Permission already decided or no API available; no prompt shown"
        );
      }
    } catch (err) {
      console.warn("[OneSignal] permission flow errored", err);
    }

    const afterPerm =
      typeof Notification !== "undefined" ? Notification.permission : "unsupported";
    console.log("[OneSignal] Notification.permission (after) =", afterPerm);

    // 5) Foreground notification handling (optional sugar)
    if (initOk && OneSignal.Notifications) {
      OneSignal.Notifications.addEventListener(
        "foregroundWillDisplay",
        async (event) => {
          console.log("[OneSignal] foregroundWillDisplay", event);
          await OneSignal.Notifications.display(event.notification);
        }
      );
    }
  });
</script>




<!-- Service Worker @ root: single registration; start heavy work only in PWA -->
<script>
if ("serviceWorker" in navigator) {
  window.addEventListener("load", async () => {
    try {
      const reg = await navigator.serviceWorker.register("/service-worker.js", {
        updateViaCache: "none",
      });

      // Try to grab a fresh version of the SW in the background
      reg.update().catch(() => {});

      const ready = await navigator.serviceWorker.ready;

      // Helper: schedule the REAL deep sitemap precache
      function scheduleBackgroundPrecache() {
        const kickOff = () => {
          navigator.serviceWorker.ready.then((r) => {
            r.active?.postMessage({ type: "PWA_START_PRECACHE" });
          });
        };

        // Prefer not to compete with initial rendering / scripting
        if ("requestIdleCallback" in window) {
          requestIdleCallback(kickOff, { timeout: 20000 }); // max 20s delay
        } else {
          // Fallback: simple timeout after first paint etc.
          setTimeout(kickOff, 20000);
        }
      }

      if (window.__isStandalone) {
        // If SW already controls this page (return visit)
        if (navigator.serviceWorker.controller) {
          scheduleBackgroundPrecache();
        } else {
          // First launch: wait until the SW takes control, then schedule
          navigator.serviceWorker.addEventListener("controllerchange", () => {
            scheduleBackgroundPrecache();
          });
        }

        // Still OK to send current page's assets early so the *first* page
        // itself becomes offlineable quickly, without hammering the network.
        const assets = new Set();
        const push = (u) => {
          try {
            assets.add(new URL(u, location.href).toString());
          } catch {}
        };

        document
          .querySelectorAll(
            'link[rel="stylesheet"], link[rel="preload"][as], script[src], img[src], source[srcset], video[src], audio[src]'
          )
          .forEach((el) => {
            if (el.href) push(el.href);
            if (el.src) push(el.src);
            if (el.srcset)
              el.srcset
                .split(",")
                .forEach((s) => push(s.trim().split(" ")[0]));
          });

        // Also cache the "root" landing page
        assets.add(new URL("/", location.origin).toString());

        ready.active?.postMessage({
          type: "PWA_ASSETS",
          assets: [...assets],
        });
      }
    } catch (e) {
      console.warn("[PWA] SW register failed", e);
    }
  });
}
</script>


<!-- Install banner: shows on website; suppressed inside PWA -->
<script>
(function(){
  if (window.__isStandalone) return; // don't show inside installed app

  const style = document.createElement('style');
  style.textContent = `
    .pwa-banner{position:fixed;left:0;right:0;bottom:0;z-index:99999;display:none;
      background:#111;color:#fff;box-shadow:0 -8px 24px rgba(0,0,0,.25)}
    .pwa-banner-inner{max-width:960px;margin:0 auto;padding:12px 16px;display:flex;gap:12px;align-items:center}
    .pwa-banner img{height:40px;width:40px;border-radius:8px;flex:none}
    .pwa-banner .txt{flex:1;line-height:1.3}
    .pwa-banner .actions{display:flex;gap:8px}
    .pwa-banner .actions button{background:#fff;color:#111;border:0;border-radius:8px;padding:8px 12px;cursor:pointer}
    .pwa-banner .close{background:transparent;color:#fff;border:1px solid #fff;opacity:.7}
    @media (prefers-color-scheme:light){
      .pwa-banner{background:#fff;color:#111;border-top:1px solid #e5e5e5}
      .pwa-banner .actions button{background:#111;color:#fff}
      .pwa-banner .close{color:#111;border-color:#111}
    }
  `;
  document.head.appendChild(style);

  const wrap = document.createElement('div');
  wrap.className = 'pwa-banner';
  wrap.innerHTML = `
    <div class="pwa-banner-inner" role="dialog" aria-live="polite" aria-label="Install app">
      <img src="/icons/icon-192.png" alt="">
      <div class="txt" id="pwa-banner-text"></div>
      <div class="actions">
        <button class="cta" id="pwa-banner-cta"></button>
        <button class="close" id="pwa-banner-close" aria-label="Dismiss">Close</button>
      </div>
    </div>`;
  document.addEventListener('DOMContentLoaded', () => document.body.appendChild(wrap));

  const isIOS = /iphone|ipad|ipod/i.test(navigator.userAgent);
  let deferredPrompt = null;

  function showOnce() {
    if (localStorage.getItem('pwaInstallDismissed') === '1') return;
    wrap.style.display = 'block';
  }
  function hide() {
    wrap.style.display = 'none';
    localStorage.setItem('pwaInstallDismissed', '1');
  }

  if (isIOS) {
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('pwa-banner-text').textContent =
        'On iOS: tap Share, then “Add to Home Screen” to install.';
      const cta = document.getElementById('pwa-banner-cta');
      cta.textContent = 'Got it';
      cta.onclick = hide;
      document.getElementById('pwa-banner-close').onclick = hide;
      showOnce();
    });
    return;
  }

  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    document.getElementById('pwa-banner-text').textContent = 'Install this app for quick, offline access.';
    const cta = document.getElementById('pwa-banner-cta');
    cta.textContent = 'Install';
    cta.onclick = async () => {
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      try { await deferredPrompt.userChoice; } finally { deferredPrompt = null; hide(); }
    };
    document.getElementById('pwa-banner-close').onclick = hide;
    showOnce();
  });
})();
</script>

<!-- PWA toasts: progress & “new content” — with debug logging -->
<script>
  (function () {
    // For debugging, allow ?source=pwa-debug to turn this on in a normal tab.
    const isStandalone =
      window.matchMedia("(display-mode: standalone)").matches ||
      window.navigator.standalone === true ||
      window.location.search.includes("source=pwa-debug");

    if (!isStandalone) {
      console.info("[PWA] Toast listener disabled (not standalone / no ?source=pwa-debug)");
      return;
    }

    function toast(text, withButton) {
      const el = document.createElement("div");
      el.className = "pwa-toast";
      el.style.cssText =
        "position:fixed;left:12px;bottom:12px;background:#111;color:#fff;padding:8px 12px;border-radius:8px;z-index:99999;font:14px system-ui";
      if (matchMedia("(prefers-color-scheme: light)").matches) {
        el.style.background = "#fff";
        el.style.color = "#111";
        el.style.border = "1px solid #e5e5e5";
      }
      el.textContent = text;
      if (withButton) {
        const btn = document.createElement("button");
        btn.textContent = "Refresh";
        btn.style.marginLeft = "8px";
        btn.onclick = () => location.reload();
        el.appendChild(btn);
      }
      document.body.appendChild(el);
      setTimeout(() => el.remove(), withButton ? 10000 : 2500);
      return el;
    }

    let progressEl = null;

    if (!navigator.serviceWorker) {
      console.warn("[PWA] No navigator.serviceWorker available");
      return;
    }

    navigator.serviceWorker.addEventListener("message", (e) => {
      console.log("[PWA msg from SW]", e.data);
      const { type, done, total, reason, from } = e.data || {};

      if (type === "PWA_PRECACHE_PROGRESS") {
        if (!progressEl) progressEl = toast(`Caching pages… ${done}/${total}`, false);
        else progressEl.textContent = `Caching pages… ${done}/${total}`;
      }

      if (type === "PWA_PRECACHE_DONE") {
        progressEl?.remove();
        progressEl = null;
        toast("All pages cached for offline use", false);
      }

      if (type === "PWA_CONTENT_UPDATED") {
        toast("New content downloaded — refresh to see it", true);
      }

      if (type === "PWA_PRECACHE_ERROR") {
        toast("Caching error: " + (reason || "Unknown"), false);
      }

      if (type === "PWA_DEBUG_PAGES") {
        console.log("[PWA DEBUG_PAGES]", e.data);
      }
    });
  })();
</script>

